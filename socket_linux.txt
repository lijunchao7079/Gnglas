在linux中，我们发送数据需要进行数据包的协议封装
及:
    
        {链路层{网络层{传输层{应用层{数据包}}}}}

arp 是存储的我们的物理地址，即计算机的网卡硬件地址
ip的字节段是32位字节
tcp/udp port 16位 最大可传输65535

socket---套接字

linux中一个文件只有两个缓冲区，分别是读和写，两个缓冲去互不干扰，
当对文件进行读的时候不会影响你的写入，两个缓冲区都是独立的




socket---套接字

linux中一个文件只有两个缓冲区，分别是读和写，两个缓冲去互不干扰，及
两个文件的缓冲区都是相互独立的


              读--> [文件]<--写


而在socket的编成中
文件的传输也是分为两个端，一个是发送端一个是接受端，
发送的端数据由接受端接手数据

        |----[发送端]---------->[接受端]-----|

       sfd                                   cfd

        |----[接收端]<----------[发送端]-----|

socket和linux文件的缓冲同理
所以我们在进行socket是成对出现的
socket需要绑定一个ip地址

在进行网络传输的时候由本地发送数据，到路由上，路由根据自己的路由表
选择下一个路由，这下一个路由称为下一跳，
如果路由的下一跳，断网，此时路由也无处可走，那么他将报错，并原路返回，到
自己的发送端


前面我们说了，数据的发送，其实还有一个需要说的就是字节序
在我们的网络中字节序是用大端法存储，而我们的操作系统是用的小端法存储，
先讲一下大端法存储

例：
int a = 0x12345678

        地址  大端法  小端法
        1004 |  78      12
        1003 |  56      34
        1002 |  34      56
        1001 |  12      78
而我们使用的计算机是进行小端法存储的，
所一我们需要进行字节序的转换

在c语言中可以使用 <arpa/inet.h>库
uint32_t htonl(uint32_t hostlong)   前面讲过32位的ip，在此是将本地字节序转换
网络字节序
uint16_t htons(uint32_t hostshort)  16位端口号，在此是将本地端口号转换成网络
字节序
uint32_t ntonl(uint32_t hctlong)    网络字节序转换成本地字节序
uint16_t ntohs(uint16_t hetsshort)  网络字节序列转换成本地字节序列

